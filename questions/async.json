{
  "module": "Async",
  "questions": [
    {
      "id": "async_001",
      "title": "异步HTTP请求处理",
      "description": "需要实现一个异步HTTP请求处理函数，要求：\n- 并发处理多个HTTP请求\n- 请求超时设置为5秒\n- 失败的请求应该返回错误信息\n- 成功的请求应该返回响应数据",
      "code": "use tokio::time::{timeout, Duration};\n\nasync fn process_urls(urls: Vec<&str>) -> Vec<Result<String, String>> {\n    let mut results = Vec::new();\n    \n    for url in urls {\n        let result = timeout(Duration::from_secs(5), fetch_url(url)).await;\n        match result {\n            Ok(Ok(data)) => results.push(Ok(data)),\n            Ok(Err(e)) => results.push(Err(format!(\"请求失败: {}\", e))),\n            Err(_) => results.push(Err(\"请求超时\".to_string())),\n        }\n    }\n    \n    results\n}\n\nasync fn fetch_url(url: &str) -> Result<String, Box<dyn std::error::Error>> {\n    // 模拟HTTP请求\n    Ok(format!(\"响应数据来自: {}\", url))\n}",
      "options": [
        {
          "id": "opt_a",
          "content": "缺少并发处理，应该使用 join! 或 try_join_all",
          "is_correct": true
        },
        {
          "id": "opt_b",
          "content": "超时处理是正确的",
          "is_correct": false
        },
        {
          "id": "opt_c",
          "content": "错误处理缺少具体的错误类型",
          "is_correct": true
        },
        {
          "id": "opt_d",
          "content": "函数签名应该返回 Future",
          "is_correct": false
        },
        {
          "id": "opt_e",
          "content": "顺序处理导致性能不佳",
          "is_correct": true
        },
        {
          "id": "opt_f",
          "content": "此代码实现完全正确",
          "is_correct": false
        }
      ],
      "explanations": {
        "opt_a": "当前代码是顺序处理，没有利用异步的并发优势，应该使用 join! 或类似方法",
        "opt_b": "超时处理使用了正确的 tokio::time::timeout",
        "opt_c": "使用 Box<dyn std::error::Error> 虽然可以编译，但对于HTTP请求应该有更具体的错误类型",
        "opt_d": "异步函数返回 impl Future 是正确的，这里的返回类型是合适的",
        "opt_e": "for 循环导致请求串行执行，没有发挥异步并发的优势",
        "opt_f": "代码存在并发性能问题"
      },
      "key_points": [
        "异步代码的关键是要真正实现并发，而不只是使用 async/await 语法",
        "join! 和 try_join! 是实现并发的重要工具",
        "错误处理要考虑异步场景的特殊性"
      ]
    },
    {
      "id": "async_002",
      "title": "微服务通信协调器",
      "description": "需要实现一个微服务通信协调器，要求：\n- 调用多个微服务获取不同数据\n- 部分服务失败不影响整体结果\n- 设置合理的超时时间\n- 返回聚合后的服务响应",
      "code": "use tokio::time::{timeout, Duration, sleep};\nuse std::time::Instant;\n\n#[derive(Debug)]\nstruct ServiceResponse {\n    service_name: String,\n    data: Option<String>,\n    error: Option<String>,\n    duration_ms: u64,\n}\n\n#[derive(Debug)]\nstruct AggregatedResponse {\n    user_service: ServiceResponse,\n    order_service: ServiceResponse,\n    payment_service: ServiceResponse,\n    total_duration_ms: u64,\n}\n\nasync fn coordinate_services(user_id: u64) -> AggregatedResponse {\n    let start_time = Instant::now();\n    \n    let user_future = call_user_service(user_id);\n    let order_future = call_order_service(user_id);\n    let payment_future = call_payment_service(user_id);\n    \n    let user_result = user_future.await;\n    let order_result = order_future.await;\n    let payment_result = payment_future.await;\n    \n    let total_duration = start_time.elapsed().as_millis() as u64;\n    \n    AggregatedResponse {\n        user_service: user_result,\n        order_service: order_result,\n        payment_service: payment_result,\n        total_duration_ms: total_duration,\n    }\n}\n\nasync fn call_user_service(user_id: u64) -> ServiceResponse {\n    let start = Instant::now();\n    let result = timeout(Duration::from_millis(500), fetch_user_data(user_id)).await;\n    let duration = start.elapsed().as_millis() as u64;\n    \n    match result {\n        Ok(Ok(data)) => ServiceResponse {\n            service_name: \"user_service\".to_string(),\n            data: Some(data),\n            error: None,\n            duration_ms: duration,\n        },\n        Ok(Err(e)) => ServiceResponse {\n            service_name: \"user_service\".to_string(),\n            data: None,\n            error: Some(e),\n            duration_ms: duration,\n        },\n        Err(_) => ServiceResponse {\n            service_name: \"user_service\".to_string(),\n            data: None,\n            error: Some(\"timeout\".to_string()),\n            duration_ms: 500,\n        },\n    }\n}\n\nasync fn call_order_service(user_id: u64) -> ServiceResponse {\n    // 类似的实现...\n    ServiceResponse {\n        service_name: \"order_service\".to_string(),\n        data: Some(\"order data\".to_string()),\n        error: None,\n        duration_ms: 200,\n    }\n}\n\nasync fn call_payment_service(user_id: u64) -> ServiceResponse {\n    // 类似的实现...\n    ServiceResponse {\n        service_name: \"payment_service\".to_string(), \n        data: Some(\"payment data\".to_string()),\n        error: None,\n        duration_ms: 300,\n    }\n}\n\nasync fn fetch_user_data(user_id: u64) -> Result<String, String> {\n    sleep(Duration::from_millis(100)).await;\n    Ok(format!(\"user data for {}\", user_id))\n}",
      "options": [
        {
          "id": "opt_a",
          "content": "服务调用是串行执行的，没有实现真正的并发",
          "is_correct": true
        },
        {
          "id": "opt_b",
          "content": "代码重复太多，应该提取通用的服务调用逻辑",
          "is_correct": true
        },
        {
          "id": "opt_c",
          "content": "总执行时间计算不准确，应该是并发时间而非累计时间",
          "is_correct": true
        },
        {
          "id": "opt_d",
          "content": "缺少对所有服务调用的统一超时控制",
          "is_correct": true
        },
        {
          "id": "opt_e",
          "content": "应该使用 Result 返回类型而不是在结构体中包含错误",
          "is_correct": false
        },
        {
          "id": "opt_f",
          "content": "此代码的异步协调实现完全正确",
          "is_correct": false
        }
      ],
      "explanations": {
        "opt_a": "当前代码依次 await 每个 future，应该使用 join! 或 try_join! 实现真正的并发调用",
        "opt_b": "call_user_service、call_order_service、call_payment_service 有大量重复代码，应该抽象出通用函数",
        "opt_c": "串行执行时总时间是各服务时间之和，并发执行时应该是最长服务的时间",
        "opt_d": "除了单个服务超时，还应该对整体协调过程设置超时，防止整体操作时间过长",
        "opt_e": "在微服务协调场景中，部分服务失败是常见情况，结构体包含错误信息是合理的设计",
        "opt_f": "代码存在并发实现和代码结构问题"
      },
      "key_points": [
        "使用 join! 或 tokio::spawn 实现真正的并发，避免串行等待",
        "抽象重复的异步逻辑，提高代码复用性",
        "微服务协调要考虑整体超时和容错设计"
      ]
    }
  ]
}