# Rust AI Coding 做题模块设计文档

## 🎯 核心理念

### 目标用户
- **AI Coding 用户**：已在使用 Claude/ChatGPT/Copilot 写 Rust 代码的开发者
- **快速上手者**：有其他语言经验，想快速具备 Rust Code Review 能力的开发者
- **Code Reviewer**：需要审查 AI 生成的 Rust 代码质量的技术负责人

### 核心能力考查
1. **程序理解能力** - 能看懂 Rust 代码的基本语法和程序逻辑
2. **需求实现完整性检查** - 快速判断 AI 代码是否完全实现了业务需求
3. **逻辑一致性审查** - 发现代码逻辑中的矛盾、遗漏或不合理之处
4. **边界情况识别** - 判断 AI 是否考虑了异常输入、极端值等边界情况
5. **业务合理性评估** - 从产品角度判断实现方式是否合适

### 明确不考查的内容
- ❌ **编译错误修复** - 编译不过的代码让 AI 直接修复即可
- ❌ **深度语法细节** - 不深入考查复杂的所有权、生命周期、宏等高级特性
- ❌ **性能优化技巧** - 不深入 Rust 特有的性能优化手段
- ❌ **代码风格规范** - 不纠结命名、格式等风格问题

## 🎪 做题流程设计

### 出题时机和流程
```
用户运行模块示例代码 
    ↓
显示代码执行结果
    ↓
自动出现一道与该模块相关的题目
    ↓
用户答题
    ↓
┌─ 做对了 ─→ 显示祝贺信息 ─→ 回到主菜单
└─ 做错了 ─→ 显示选项正误状态（用背景颜色标识）─→ 让用户继续选择 ─→ 循环直到做对 ─→ 显示正确答案和详细解释  随机出下一道同模块题 ─→ 循环直到第一次就做对
```

### 随机化机制
1. **题目随机选择**：从当前模块的题库中随机选取
2. **选项顺序随机**：每次出题时打乱选项顺序（A-J 位置变化）
3. **避免重复**：短时间内尽量避免连续出现相同题目
4. **答错重试**：答错后的重新出题也是随机的

### 用户体验设计
- **一次通过**：做对了就结束，效率优先
- **错误学习**：做错了强制学习解释，确保理解
- **无限重试**：直到做对为止，不惩罚学习过程
- **状态清理**：不持久化保存做对做错的记录，每次启动都是全新状态

## 📋 题目设计原则

### 基本原则
1. **前置条件**
   - 所有代码都能编译通过并运行
   - 代码功能基本可用（不是完全错误的实现）
   - 模拟真实 AI 生成代码的质量水平
   - 用户需要能看懂基本的 Rust 语法

2. **业务场景导向**
   - 每道题都有明确的业务背景和需求描述
   - 重点考查"代码是否满足业务需求"而非纯技术语法
   - 模拟真实的 Code Review 工作场景

3. **逻辑推理为主**
   - 重点考查理解程序逻辑的能力
   - 避免纯粹的语法知识记忆题
   - 培养"看懂代码在干什么"的核心技能

### 多选题设计要点
- **选项数量**：每题 5-9 个选项，增加难度，减少蒙对几率
- **正确答案数**：通常 2-8 个正确选项，确保有挑战性
- **选项顺序**：每次出题时随机打乱，避免记忆位置
- **干扰项质量**：错误选项要有迷惑性但逻辑合理

## 🎪 题目模板

### 标准题目格式
```markdown
## 题目：[简短的业务场景描述]

### 需求说明
[详细的业务需求，包括：
- 功能要求
- 输入输出规格
- 边界条件
- 异常处理要求]

### AI 生成的代码
```rust
[能编译通过但可能有逻辑问题的 Rust 代码]
```

### 问题：作为 Code Reviewer，你认为这段代码存在哪些问题？（多选）

A. [需求实现相关的问题]
B. [逻辑一致性问题] 
C. [边界情况处理问题]
D. [错误处理问题]
E. [数据结构选择问题]
F. [业务逻辑合理性问题]
G. [安全性或健壮性问题]
H. [合理的干扰项]
I. [此代码实现完全正确]

### 正确答案：[如：A, C, F]

### 详细解释
**正确选项：**
- A: [为什么这是问题] → [建议如何改进]
- C: [为什么这是问题] → [建议如何改进]  
- F: [为什么这是问题] → [建议如何改进]

**错误选项：**
- B: [为什么这不是问题]
- D: [为什么这不是问题]
- ...

**关键学习点：**
[总结这道题要掌握的核心概念]

## 📚 模块题目设计规划

### 各模块重点考查内容

| 模块 | 文件 | 重点考查内容 | 建议题目数 |
|------|------|-------------|-----------|
| **Options** | `options.rs` | `Option<T>`/`Result<T,E>`/`Result<Option<T>, E>` 的正确使用，错误处理的完整性 | 6-8 题 |
| **Async** | `async_demo.rs` | 异步逻辑的完整性，`.await` 的使用场景，异步函数的正确调用 | 5-7 题 |
| **Errors** | `errors.rs` | 错误处理的层次设计，上下文信息的完整性，`anyhow` 的正确使用 | 5-7 题 |
| **Iterators** | `iterators.rs` | 迭代器链的逻辑正确性，集合操作的效率，`fold`/`reduce` 的使用 | 6-8 题 |
| **Concurrency** | `concurrency.rs` | 并发安全性，数据竞争问题，`join!`/`select!` 的正确使用 | 4-6 题 |
| **Logging** | `logging.rs` | 日志级别的合理性，日志信息的完整性，`tracing` 的正确使用 | 4-6 题 |
| **Pattern Matching** | `pattern_matching.rs` | 模式匹配的完整性，分支逻辑的正确性，`match`/`if let` 的使用 | 5-7 题 |
| **I/O Boundaries** | `io_boundaries.rs` | 同步异步边界的正确处理，I/O 错误的处理，资源管理 | 5-7 题 |

### 题目类型分类

#### 1. **需求遗漏检查类**
- AI 代码功能不完整，缺少某些必要功能
- 输入验证缺失
- 输出格式不符合要求
- 关键业务逻辑缺失

#### 2. **逻辑矛盾识别类**
- 代码内部逻辑前后矛盾
- 条件判断错误
- 状态转换不一致
- 数据处理逻辑错误

#### 3. **边界条件缺失类**
- 缺少对空值的处理
- 缺少对异常输入的验证
- 缺少对极端值的处理
- 缺少对并发情况的考虑

#### 4. **错误处理不当类**
- `unwrap()` 滥用
- 错误信息不清晰
- 错误传播不正确
- 缺少必要的错误处理

#### 5. **业务理解偏差类**
- 技术实现正确但不符合业务逻辑
- 数据结构选择不当
- 算法效率问题
- 安全性考虑不足

## 🎯 选项设计策略

### 正确选项类型
1. **明显问题** - 容易发现的功能缺失或逻辑错误
2. **微妙问题** - 需要仔细分析才能发现的问题
3. **边界问题** - 异常情况处理的缺失
4. **业务问题** - 技术实现正确但业务逻辑不合理

### 干扰选项类型
1. **过度挑剔** - 实际上不是问题的"问题"
2. **超出需求** - 需求没要求但技术上更好的"优化"
3. **语法偏好** - 不影响功能的代码风格差异
4. **完全正确** - "此代码实现完全正确"类选项

### 选项设计技巧
- **选项长度相似** - 避免通过长度猜答案
- **语法结构统一** - 保持选项描述的一致性
- **难度递进** - 从明显到微妙，测试不同水平
- **实用导向** - 选项描述贴近实际工作场景

## 📊 评估和反馈机制

### 成功反馈
```
🎉 恭喜！你成功识别了代码中的问题。
作为一名优秀的 Code Reviewer，你具备了审查 AI 生成 Rust 代码的核心能力！

✅ 你正确识别了：[正确选项及原因]

继续保持这种审查思维，在实际 AI Coding 中你会更加高效！
```

### 失败反馈模板
```
📚 再想想看！

选项状态提示：
A. [选项内容] ✅ (正确)
B. [选项内容] ❌ (错误)  
C. [选项内容] ✅ (正确)
D. [选项内容] ❌ (错误)
...

💡 提示：根据上面的状态指示，重新选择正确的选项组合

继续选择你认为正确的选项...
```

### 反馈设计原则
- **正面鼓励** - 做对了要有成就感
- **建设性批评** - 做错了要有学习价值
- **实用导向** - 解释要联系实际工作场景
- **简洁明了** - 避免过长的理论讲解

## 🛠️ 技术实现要点

### 数据结构设计
```rust
#[derive(Debug, Clone)]
pub struct Question {
    pub id: String,
    pub module: String,
    pub title: String,
    pub description: String,
    pub code: String,
    pub options: Vec<QuestionOption>,
    pub explanations: HashMap<String, String>, // option_id -> explanation
    pub key_points: Vec<String>,
}

#[derive(Debug, Clone)]
pub struct QuestionOption {
    pub id: String,          // 唯一标识，不随顺序变化
    pub content: String,     // 选项内容
    pub is_correct: bool,    // 是否正确答案
}

#[derive(Debug)]
pub struct QuizSession {
    pub module: String,
    pub current_question: Option<Question>,
    pub question_state: QuestionState,
    pub attempt_count: usize,
    pub completed: bool,
}

#[derive(Debug)]
pub struct QuestionState {
    pub displayed_options: Vec<QuestionOption>, // 当前显示的选项顺序（随机化后）
    pub user_selections: HashSet<String>,       // 用户选择的选项ID
    pub current_focus: usize,                   // 当前焦点位置（键盘导航）
    pub phase: AnswerPhase,                     // 答题阶段
    pub revealed_status: HashMap<String, bool>, // 已显示的选项状态 (option_id -> is_correct)
}

#[derive(Debug, PartialEq)]
pub enum AnswerPhase {
    FirstAttempt,      // 首次答题
    ShowingHints,      // 显示提示（选项正误状态）
    FinalAnswer,       // 查看最终答案和解释
}
```

### 关键功能
1. **题库管理** - 按模块组织题目，支持随机选择
2. **选项随机化** - 每次出题打乱选项顺序
3. **答案验证** - 多选题的部分匹配和完全匹配
4. **反馈生成** - 根据用户答案生成个性化反馈
5. **进度跟踪** - 记录模块完成状态（可选）

### 用户交互设计
- **清晰的题目展示** - 代码语法高亮，选项编号清晰
- **键盘导航交互** - 使用上下箭头键或 j/k 键移动，空格键选择/取消选择，回车键提交
- **视觉状态反馈** - 用背景颜色显示选项的正确/错误/未选择状态
- **错误时渐进提示** - 不直接给出答案，而是显示每个选项的对错状态让用户继续思考
- **优雅的错误处理** - 输入格式错误的友好提示

## 🎯 质量保证

### 题目质量检查清单
- [ ] 代码能编译通过且逻辑基本正确
- [ ] 需求描述清晰具体
- [ ] 正确选项确实是问题
- [ ] 干扰选项有合理性
- [ ] 解释清楚且有教学价值
- [ ] 符合模块主题

### 测试策略
1. **内容测试** - 验证题目逻辑和答案正确性
2. **用户测试** - 不同水平用户的使用体验
3. **随机性测试** - 确保随机化功能正常
4. **边界测试** - 异常输入和错误处理

## 📈 后续优化方向

### 短期优化
- 增加题目数量和质量
- 优化用户界面和体验
- 添加详细的统计功能

### 长期规划
- 难度自适应调节
- 个性化题目推荐
- 学习路径建议
- 与实际项目结合的题目

---

**设计理念**：通过精心设计的题目训练用户成为优秀的 AI Rust 代码 Reviewer，在 AI Coding 时代具备核心竞争力！🦀✨
