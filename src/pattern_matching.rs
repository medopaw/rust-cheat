/*

# 07. æ¨¡å¼åŒ¹é… - AI Coding å¿«é€Ÿç†è§£æŒ‡å—

---

## ğŸ¯ ä¸šåŠ¡åœºæ™¯å¯¹ç…§è¡¨

| ç±»å‹ | ç”¨é€” | å…¸å‹ç¤ºä¾‹ |
|------|------|----------|
| `match` | ç©·å°½åŒ¹é…ï¼Œå¿…é¡»å¤„ç†æ‰€æœ‰æƒ…å†µ | çŠ¶æ€æœºå¤„ç†ã€é”™è¯¯åˆ†ç±» |
| `if let` | åªå…³å¿ƒä¸€ç§æƒ…å†µï¼Œå…¶ä»–å¿½ç•¥ | Option å€¼æå–ã€å•ä¸€æ¡ä»¶æ£€æŸ¥ |
| è§£æ„ | ä»å¤æ‚ç»“æ„ä¸­æå–å­—æ®µ | API å“åº”å¤„ç†ã€å‚æ•°è§£æ |
| å®ˆå« | åœ¨åŒ¹é…åŸºç¡€ä¸ŠåŠ æ¡ä»¶ | æ•°å€¼èŒƒå›´æ£€æŸ¥ã€æ¡ä»¶è¿‡æ»¤ |

## ğŸ” 30ç§’è¯†åˆ«è¦ç‚¹

**å¿«é€Ÿåˆ¤æ–­æ–¹æ³•ï¼š**

- ğŸ‘€ **çœ‹åŒ¹é…ç±»å‹**: `match` = å…¨è¦†ç›–ï¼Œ`if let` = å•ä¸€å…³æ³¨
- ğŸ”§ **çœ‹è§£æ„æ¨¡å¼**: `(x, y)`, `{name, age}` æå–å­—æ®µ  
- âš ï¸ **çœ‹æ‰€æœ‰æƒ**: æ˜¯å¦ä¸å¿…è¦çš„ `clone()`ï¼Ÿ

## âš ï¸ AI å¸¸è§é—®é¢˜è­¦å‘Š

> **å±é™©ä¿¡å·** ğŸš¨

- ğŸ”´ **è¿‡åº¦ unwrap** ä½¿ç”¨ `unwrap()` è€Œä¸æ˜¯æ¨¡å¼åŒ¹é…å¤„ç† Option/Result
- ğŸ”´ **åˆ†æ”¯ä¸å…¨** æ¼æ‰ match åˆ†æ”¯ï¼Œå¯¼è‡´ç¼–è¯‘é”™è¯¯æˆ–é€»è¾‘ç¼ºå¤±  
- ğŸ”´ **if let é“¾** é“¾å¼ if let å¤ªé•¿ï¼Œåº”è¯¥ç”¨ match æ›´æ¸…æ™°
- ğŸ”´ **æ‰€æœ‰æƒæµªè´¹** è§£æ„æ—¶ä¸å¿…è¦çš„ clone()

## âœ… Code Review æ£€æŸ¥æ¸…å•

â˜ æ‰€æœ‰ match åˆ†æ”¯æ˜¯å¦å®Œæ•´è¦†ç›–ï¼Ÿ  
â˜ æ˜¯å¦é€‰æ‹©äº†åˆé€‚çš„åŒ¹é…æ–¹å¼ï¼ˆmatch vs if letï¼‰ï¼Ÿ  
â˜ è§£æ„æ˜¯å¦é«˜æ•ˆï¼ˆé¿å…ä¸å¿…è¦çš„ cloneï¼‰ï¼Ÿ  
â˜ æ¨¡å¼æ˜¯å¦è¡¨è¾¾äº†ä¸šåŠ¡æ„å›¾ï¼Ÿ  
â˜ æ˜¯å¦æœ‰è¿‡äºå¤æ‚çš„å®ˆå«æ¡ä»¶ï¼Ÿ

## ğŸ“– æ¨èé˜…è¯»é¡ºåº

**Step 1: åŒ¹é…è¦†ç›–æ£€æŸ¥**  
å…ˆçœ‹ match åˆ†æ”¯æ˜¯å¦å®Œæ•´ï¼Œæœ‰æ— é—æ¼

**Step 2: æ‰€æœ‰æƒåˆ†æ**  
å†çœ‹è§£æ„å’Œç§»åŠ¨è¯­ä¹‰æ˜¯å¦åˆç†

**Step 3: æ€§èƒ½ä¼˜åŒ–éªŒè¯**  
æœ€åçœ‹æ˜¯å¦æœ‰ä¸å¿…è¦çš„ clone æˆ–å¤æ‚åŒ¹é…

---

> ğŸ’¡ **è®°ä½**: æ¨¡å¼åŒ¹é…è®©ç¼–è¯‘å™¨å¸®ä½ æ‰¾ bugï¼Œåˆ©ç”¨å¥½è¿™ä¸ªç‰¹æ€§ï¼

ğŸ“– é˜…è¯»é¡ºåºï¼š
1. å…ˆçœ‹åŒ¹é…å¯¹è±¡çš„ç±»å‹ï¼ˆOption, Result, enum, tupleï¼‰
2. å†çœ‹åˆ†æ”¯è¦†ç›–æƒ…å†µï¼ˆæ˜¯å¦æœ‰é—æ¼çš„æƒ…å†µï¼‰
3. æœ€åçœ‹æ¯ä¸ªåˆ†æ”¯çš„å¤„ç†é€»è¾‘ï¼ˆæ˜¯å¦åˆç†ï¼‰

æ ¸å¿ƒæ¨¡å¼ç¤ºä¾‹ï¼š

```rust
// åŸºæœ¬çš„åŒ¹é…æ¨¡å¼ç¤ºä¾‹
pub fn match_quick(opt_a: Option<i32>, opt_b: Option<i32>) {
    match (opt_a, opt_b) {
        (Some(a), Some(b)) => println!("both: {} {}", a, b),
        (Some(a), None)    => println!("only a: {}", a),
        _                  => println!("other"),
    }

    if let Some(x) = Some(10) {
        println!("x={}", x);
    } else {
        println!("none");
    }

    if let Err(e) = "abc".parse::<i32>().map_err(|_| "parse err") {
        println!("err={}", e);
    }
}

// è§£æ„å’Œå®ˆå«çš„ä¾‹å­
let point = (3, 4);
match point {
    (0, 0) => println!("åŸç‚¹"),
    (x, 0) => println!("xè½´ä¸Šçš„ç‚¹: {}", x),
    (0, y) => println!("yè½´ä¸Šçš„ç‚¹: {}", y),
    (x, y) => println!("ç‚¹ ({}, {})", x, y),
}

let num = Some(5);
match num {
    Some(x) if x > 3 => println!("å¤§äº3çš„æ•°: {}", x),
    Some(x) => println!("å°äºç­‰äº3çš„æ•°: {}", x),
    None => println!("æ— å€¼"),
}
```

*/

pub fn match_quick(opt_a: Option<i32>, opt_b: Option<i32>) {
    match (opt_a, opt_b) {
        (Some(a), Some(b)) => println!("both: {} {}", a, b),
        (Some(a), None)    => println!("only a: {}", a),
        _                  => println!("other"),
    }

    if let Some(x) = Some(10) {
        println!("x={}", x);
    } else {
        println!("none");
    }

    if let Err(e) = "abc".parse::<i32>().map_err(|_| "parse err") {
        println!("err={}", e);
    }
}

pub fn pattern_matching_demo() {
    println!("æ¨¡å¼åŒ¹é…æ¼”ç¤ºï¼š");
    
    // åŸºæœ¬åŒ¹é…
    match_quick(Some(1), Some(2));
    match_quick(Some(1), None);
    match_quick(None, None);
    
    // è§£æ„åŒ¹é…
    let point = (3, 4);
    match point {
        (0, 0) => println!("åŸç‚¹"),
        (x, 0) => println!("xè½´ä¸Šçš„ç‚¹: {}", x),
        (0, y) => println!("yè½´ä¸Šçš„ç‚¹: {}", y),
        (x, y) => println!("ç‚¹ ({}, {})", x, y),
    }
    
    // å®ˆå«æ¡ä»¶
    let num = Some(5);
    match num {
        Some(x) if x > 3 => println!("å¤§äº3çš„æ•°: {}", x),
        Some(x) => println!("å°äºç­‰äº3çš„æ•°: {}", x),
        None => println!("æ— å€¼"),
    }
}